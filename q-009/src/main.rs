// -*- coding:utf-8-unix -*-

use proconio::input;

/// とりうるパターンを全探索すると計算量が O(2^n) かかるため、動的計画法を使う。
///
/// 使用したカードの枚数を `i`、合計値を `j` とおくと以下のような二次元配列が作れる。
/// N=3、S=11 のケースを表にまとめると以下の通り。
///
/// | i/j | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 |
/// | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
/// | 0 | `dp[0][0]` | `dp[0][1]` | `dp[0][2]` | `dp[0][3]` | `dp[0][4]` | `dp[0][5]` | `dp[0][6]` | `dp[0][7]` | `dp[0][8]` | `dp[0][9]` | `dp[0][10]` | `dp[0][11]` |
/// | 1 | `dp[1][0]` | `dp[1][1]` | `dp[1][2]` | `dp[1][3]` | `dp[1][4]` | `dp[1][5]` | `dp[1][6]` | `dp[1][7]` | `dp[1][8]` | `dp[1][9]` | `dp[1][10]` | `dp[1][11]` |
/// | 2 | `dp[2][0]` | `dp[2][1]` | `dp[2][2]` | `dp[2][3]` | `dp[2][4]` | `dp[2][5]` | `dp[2][6]` | `dp[2][7]` | `dp[2][8]` | `dp[2][9]` | `dp[2][10]` | `dp[2][11]` |
/// | 3 | `dp[3][0]` | `dp[3][1]` | `dp[3][2]` | `dp[3][3]` | `dp[3][4]` | `dp[3][5]` | `dp[3][6]` | `dp[3][7]` | `dp[3][8]` | `dp[3][9]` | `dp[3][10]` | `dp[3][11]` |
///
/// 配られたカードを使って `j` に到達可能な場合は配列に true を詰める。
/// `i` と `j` の二重ループを最後まで回して `dp[N][S]` が true の場合、合計がちょうど s になるパターンが存在する、といえる。
///
/// `dp[i][j]` の値を計算するだけで済むため、計算量は O(NS) に改善できる。
fn main() {
    input! {
        n: usize, // カードの枚数
        s: usize, // 整数の合計
        a: [usize; n], // カードのリスト。整数が書かれている
    }

    // 使用したカードの枚数と合計値を詰めた二次元配列をつくる
    let mut dp = vec![vec![false; s + 1]; n + 1];
    // 到達済みの地点に true を詰める
    dp[0][0] = true;

    // 動的計画
    for i in 1..=n {
        for j in 0..=s {
            if j < a[i - 1] {
                // 合計値 `j` がカードに書かれた整数 `a[i-1]` よりも小さいとき、カード i は選べない
                // i-1 の結果を現在の座標にそのまま引き継ぐ
                dp[i][j] = dp[i - 1][j]
            } else {
                // 合計値 `j` がカードに書かれた整数 `a[i-1]` よりも大きいとき、選ぶ / 選ばない 両方の選択肢がある
                // i 番目のカードを使って j にたどり着ける場合は true を詰める
                // カードを使わずに j にたどり着ける場合も true を詰める
                if dp[i - 1][j] || dp[i - 1][j - a[i - 1]] {
                    dp[i][j] = true
                } else {
                    // i 番目のカードを使って j にたどり着けない場合は false を詰める
                    dp[i][j] = false
                }
            }
        }
    }

    // 合計がちょうど s になるパターンが存在する場合、Yes を出力する
    println!("{}", if dp[n][s] { "Yes" } else { "No" });
}
